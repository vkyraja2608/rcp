<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f172a">
    <link rel="icon" href="data:,"> <!-- Suppress favicon 404 -->
    <title>Row & Column Picture Visualization</title>
    
    <!-- Tailwind CSS with Explicit Config -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: {
                            50: '#f8fafc', 100: '#f1f5f9', 200: '#e2e8f0', 300: '#cbd5e1', 400: '#94a3b8',
                            500: '#64748b', 600: '#475569', 700: '#334155', 800: '#1e293b', 900: '#0f172a',
                        },
                        emerald: {
                            400: '#34d399', 500: '#10b981', 600: '#059669',
                        }
                    }
                }
            }
        }
    </script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        /* Embed-friendly CSS: Use 100% instead of viewport units */
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #0f172a; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        
        .glass-panel {
            background: rgba(15, 23, 42, 0.95); 
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }

        input[type="number"] {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid #334155;
            color: white;
            padding: 4px;
            border-radius: 4px;
            width: 100%;
            text-align: center;
        }

        .toggle-btn.active {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
        }

        /* Checkbox styling */
        .vis-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #475569;
            border-radius: 4px;
            background: rgba(15, 23, 42, 0.5);
            cursor: pointer;
            position: relative;
            vertical-align: middle;
        }
        .vis-checkbox:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }
        .vis-checkbox:checked::after {
            content: '✔';
            font-size: 10px;
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .math-font { font-family: 'Times New Roman', serif; font-style: italic; }

        #sidebar-content {
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            overflow: hidden;
        }
        .collapsed #sidebar-content {
            max-height: 0;
            opacity: 0;
            padding: 0;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="flex flex-col p-2 md:p-4">
        
        <!-- Controls Container -->
        <div id="main-panel" class="pointer-events-auto glass-panel rounded-xl w-full max-w-sm flex flex-col transition-all duration-300">
            
            <!-- Header -->
            <div class="flex justify-between items-center p-4 bg-slate-900/50 rounded-t-xl cursor-pointer" onclick="toggleSidebar()">
                <div>
                    <h1 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-emerald-400">Linear Systems</h1>
                    <p class="text-[10px] text-slate-400">Strang's Row vs Column</p>
                </div>
                <button class="text-slate-400 hover:text-white transition-colors p-2">
                    <i id="chevron-icon" class="fas fa-chevron-up transform transition-transform duration-300"></i>
                </button>
            </div>

            <!-- Scrollable Content -->
            <div id="sidebar-content" class="px-4 pb-4 max-h-[60vh] md:max-h-[80vh] overflow-y-auto space-y-4">
                
                <!-- Dimension Toggle -->
                <div class="grid grid-cols-2 gap-2 bg-slate-800 p-1 rounded-lg mt-2">
                    <button id="btn-2d" onclick="setDimension(2); event.stopPropagation();" class="toggle-btn py-2 rounded-md text-xs font-bold uppercase tracking-wide text-slate-400">2D System</button>
                    <button id="btn-3d" onclick="setDimension(3); event.stopPropagation();" class="toggle-btn active py-2 rounded-md text-xs font-bold uppercase tracking-wide">3D System</button>
                </div>

                <!-- View Toggle -->
                <div class="grid grid-cols-2 gap-2 bg-slate-800 p-1 rounded-lg">
                    <button id="btn-row" onclick="setMode('row'); event.stopPropagation();" class="toggle-btn active py-2 rounded-md text-xs font-bold uppercase tracking-wide">Row Pic</button>
                    <button id="btn-col" onclick="setMode('col'); event.stopPropagation();" class="toggle-btn py-2 rounded-md text-xs font-bold uppercase tracking-wide text-slate-400">Col Pic</button>
                </div>

                <!-- Visibility Controls -->
                <div class="bg-slate-800/50 p-3 rounded-lg border border-slate-700">
                    <h3 class="text-[10px] font-bold text-slate-400 uppercase mb-2">Visibility</h3>
                    <div id="visibility-container" class="grid grid-cols-2 gap-2 text-xs">
                        <!-- Injected by JS -->
                    </div>
                </div>

                <!-- Animation & Tools Controls -->
                <div class="flex gap-2">
                    <button onclick="resetAnimation(); event.stopPropagation();" class="w-10 bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg text-sm" title="Reset Animation"><i class="fas fa-undo"></i></button>
                    <button id="play-btn" onclick="togglePlay(); event.stopPropagation();" class="flex-1 bg-emerald-600 hover:bg-emerald-500 text-white py-2 rounded-lg text-sm font-bold shadow-lg shadow-emerald-900/50">
                        <i class="fas fa-play"></i> Play
                    </button>
                    <button onclick="downloadSnapshot(); event.stopPropagation();" class="w-10 bg-blue-600 hover:bg-blue-500 text-white py-2 rounded-lg text-sm" title="Download Image"><i class="fas fa-camera"></i></button>
                </div>

                <!-- Matrix Input -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <h2 class="text-xs font-bold text-slate-400 uppercase">System (Ax = b)</h2>
                        <div class="flex gap-2">
                            <button onclick="randomizeSystem(); event.stopPropagation();" class="text-[10px] text-emerald-400 underline">Random</button>
                            <button onclick="resetToDefault(); event.stopPropagation();" class="text-[10px] text-blue-400 underline">Reset</button>
                        </div>
                    </div>
                    <div id="matrix-inputs" class="space-y-1 text-xs"></div>
                </div>

                <!-- Solution Display -->
                <div class="bg-slate-800/80 p-3 rounded-lg text-center border border-slate-700">
                    <div class="text-[10px] text-slate-500 uppercase mb-1">Solution</div>
                    <div id="solution-display" class="font-mono text-emerald-400 text-base font-bold">Computing...</div>
                </div>

                <!-- Explanation -->
                <div id="explanation-box" class="text-xs text-slate-300 leading-relaxed border-t border-slate-700 pt-3">
                    Loading...
                </div>
            </div>
        </div>

        <!-- Mode Indicator -->
        <div class="absolute top-4 right-4 pointer-events-none hidden md:block">
            <div class="glass-panel px-4 py-2 rounded-lg text-right">
                <div id="mode-title-overlay" class="text-sm font-bold text-white">Row Picture</div>
            </div>
        </div>
    </div>

    <script>
        // --- UI Logic ---
        let isSidebarOpen = true;
        let currentDim = 3;
        let visibilityState = {
            row: [true, true, true],
            col: [true, true, true, true, true],
            labels: true // Global toggle for labels
        };
        
        function toggleSidebar() {
            const panel = document.getElementById('main-panel');
            const icon = document.getElementById('chevron-icon');
            const content = document.getElementById('sidebar-content');
            
            isSidebarOpen = !isSidebarOpen;
            
            if (isSidebarOpen) {
                panel.classList.remove('collapsed');
                icon.style.transform = 'rotate(0deg)';
                content.style.maxHeight = window.innerWidth < 768 ? '60vh' : '80vh';
                content.style.opacity = '1';
                content.style.paddingBottom = '1rem';
            } else {
                panel.classList.add('collapsed');
                icon.style.transform = 'rotate(180deg)';
                content.style.maxHeight = '0';
                content.style.opacity = '0';
                content.style.paddingBottom = '0';
            }
        }

        if (window.innerWidth < 768) toggleSidebar(); 

        function renderVisibilityControls() {
            const container = document.getElementById('visibility-container');
            container.innerHTML = '';
            
            const colors = ['#ef4444', '#22c55e', '#3b82f6', '#facc15', '#cbd5e1'];
            
            const numEqs = currentDim;
            
            if (mode === 'row') {
                for (let i = 0; i < numEqs; i++) {
                    const label = `Eq ${i+1} (${i===0?'Red':i===1?'Green':'Blue'})`;
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-2';
                    div.innerHTML = `
                        <input type="checkbox" class="vis-checkbox" ${visibilityState.row[i] ? 'checked' : ''} onchange="toggleVis('row', ${i})">
                        <span style="color: ${colors[i]}" class="font-medium">${label}</span>
                    `;
                    container.appendChild(div);
                }
            } else {
                // Cols
                for (let i = 0; i < numEqs; i++) {
                    const label = `Col ${i+1} (${i===0?'Red':i===1?'Green':'Blue'})`;
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-2';
                    div.innerHTML = `
                        <input type="checkbox" class="vis-checkbox" ${visibilityState.col[i] ? 'checked' : ''} onchange="toggleVis('col', ${i})">
                        <span style="color: ${colors[i]}" class="font-medium">${label}</span>
                    `;
                    container.appendChild(div);
                }
                // Result & Volume
                ['Result (Yellow)', currentDim === 2 ? 'Parallelogram' : 'Spanned Volume'].forEach((label, idx) => {
                    const i = numEqs + idx; // Offset index
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-2';
                    div.innerHTML = `
                        <input type="checkbox" class="vis-checkbox" ${visibilityState.col[i] ? 'checked' : ''} onchange="toggleVis('col', ${i})">
                        <span style="color: ${colors[numEqs + idx]}" class="font-medium">${label}</span>
                    `;
                    container.appendChild(div);
                });
            }

            // Global Label Toggle
            const labelDiv = document.createElement('div');
            labelDiv.className = 'flex items-center gap-2 col-span-2 border-t border-slate-700 pt-2 mt-1';
            labelDiv.innerHTML = `
                <input type="checkbox" class="vis-checkbox" ${visibilityState.labels ? 'checked' : ''} onchange="toggleVis('labels', null)">
                <span class="text-slate-300 font-bold">Show Labels</span>
            `;
            container.appendChild(labelDiv);
        }

        function toggleVis(type, index) {
            if (type === 'labels') {
                visibilityState.labels = !visibilityState.labels;
            } else {
                visibilityState[type][index] = !visibilityState[type][index];
            }
            updateScene(animationTime);
        }

        // --- Math Logic ---
        const defaultMatrix3D = [[2, 1, 1, 5], [4, -6, 0, -2], [-2, 7, 2, 9]];
        const defaultMatrix2D = [[1, 2, 4], [3, -1, 5]]; 

        let matrix = JSON.parse(JSON.stringify(defaultMatrix3D));
        let solution = { u: 0, v: 0, w: 0, valid: false };

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randomizeSystem() {
            const n = currentDim;
            const sol = [];
            for(let i=0; i<n; i++) sol.push(getRandomInt(-3, 3));
            
            const newMatrix = [];
            for(let i=0; i<n; i++) {
                const row = [];
                let b = 0;
                for(let j=0; j<n; j++) {
                    const coeff = getRandomInt(-5, 5);
                    row.push(coeff);
                    b += coeff * sol[j];
                }
                row.push(b);
                newMatrix.push(row);
            }
            matrix = newMatrix;
            generateInputs();
            solveSystem();
            initVisuals();
            resetAnimation();
        }

        function setDimension(d) {
            currentDim = d;
            document.getElementById('btn-2d').className = `toggle-btn py-2 rounded-md text-xs font-bold uppercase tracking-wide ${d===2?'active':'text-slate-400'}`;
            document.getElementById('btn-3d').className = `toggle-btn py-2 rounded-md text-xs font-bold uppercase tracking-wide ${d===3?'active':'text-slate-400'}`;
            
            if(d === 2) {
                randomizeSystem(); 
            } else {
                matrix = JSON.parse(JSON.stringify(defaultMatrix3D));
                generateInputs();
                solveSystem();
                initVisuals();
                resetAnimation();
            }

            renderVisibilityControls();
        }

        function solveSystem() {
            let M = JSON.parse(JSON.stringify(matrix));
            const n = currentDim;
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
                let tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp;
                
                if (Math.abs(M[i][i]) < 1e-10) { solution = { valid: false }; updateSolutionUI(); return; }
                
                for (let k = i + 1; k < n; k++) {
                    let factor = M[k][i] / M[i][i];
                    for (let j = i; j <= n; j++) M[k][j] -= factor * M[i][j];
                }
            }
            let x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) sum += M[i][j] * x[j];
                x[i] = (M[i][n] - sum) / M[i][i];
            }
            
            if (n === 2) solution = { u: x[0], v: x[1], w: 0, valid: true };
            else solution = { u: x[0], v: x[1], w: x[2], valid: true };
            
            updateSolutionUI();
        }

        // --- Three.js Logic ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); 
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
        const container = document.getElementById('canvas-container');
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const rowGroup = new THREE.Group();
        const colGroup = new THREE.Group();
        const labelsGroup = new THREE.Group(); 
        scene.add(rowGroup);
        scene.add(colGroup);
        scene.add(labelsGroup);
        scene.add(new THREE.GridHelper(40, 40, 0x334155, 0x1e293b));
        
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        // Visuals State
        let mode = 'row'; 
        let animationTime = 0;
        let isPlaying = false;
        let animationSpeed = 0.01;

        const materials = {
            p1: new THREE.MeshPhongMaterial({ color: 0xff4444, side: 2, transparent: true, opacity: 0.3, depthWrite: false }),
            p2: new THREE.MeshPhongMaterial({ color: 0x44ff44, side: 2, transparent: true, opacity: 0.3, depthWrite: false }),
            p3: new THREE.MeshPhongMaterial({ color: 0x4444ff, side: 2, transparent: true, opacity: 0.3, depthWrite: false }),
            pt: new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00 }),
            vol: new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.3, vertexColors: true })
        };

        let planes = [], intersectPoint, vectors = [], finalVector, parallelepipedMesh;
        let sceneLabels = { row: [], col: [], point: null, result: null };

        function createTextSprite(text, color, pos, hasBg = false) {
            // Estimate width based on char count
            const estWidth = Math.max(200, text.length * 15);
            const canvas = document.createElement('canvas');
            canvas.width = estWidth; 
            canvas.height = 80;
            const ctx = canvas.getContext('2d');
            
            if (hasBg) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.beginPath();
                ctx.roundRect(5, 10, estWidth-10, 60, 15);
                ctx.fill();
            }

            ctx.fillStyle = color;
            ctx.font = 'bold 24px monospace'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, estWidth/2, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.copy(pos);
            sprite.scale.set(estWidth/50, 1.6, 1);
            sprite.renderOrder = 999; 
            return sprite;
        }

        function initVisuals() {
            while(rowGroup.children.length) rowGroup.remove(rowGroup.children[0]);
            while(colGroup.children.length) colGroup.remove(colGroup.children[0]);
            while(labelsGroup.children.length) labelsGroup.remove(labelsGroup.children[0]);
            
            planes = []; vectors = []; parallelepipedMesh = null;
            sceneLabels = { row: [], col: [], point: null, result: null };
            
            // Adjust camera
            if (currentDim === 2) {
                camera.position.set(0, 0, 30);
                controls.target.set(0, 0, 0);
            } else {
                camera.position.set(15, 15, 20);
                controls.target.set(0, 0, 0);
            }
            controls.update();

            // Axis Labels
            labelsGroup.add(createTextSprite("U (x)", "#ffaaaa", new THREE.Vector3(11, 0, 0)));
            labelsGroup.add(createTextSprite("V (y)", "#aaffaa", new THREE.Vector3(0, 11, 0)));
            if (currentDim === 3) labelsGroup.add(createTextSprite("W (z)", "#aaaaff", new THREE.Vector3(0, 0, 11)));

            if (!solution.valid) return;

            const colors = ['#ef4444', '#22c55e', '#3b82f6'];

            // --- ROW PICTURE ---
            if (currentDim === 3) {
                // 3D Planes
                matrix.forEach((row, i) => {
                    const [a, b, c, d] = row;
                    const normal = new THREE.Vector3(a, b, c);
                    if(normal.lengthSq() < 0.001) return;
                    
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), i==0?materials.p1:i==1?materials.p2:materials.p3);
                    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize());
                    const centerPos = normal.clone().multiplyScalar(d/normal.lengthSq());
                    mesh.position.copy(centerPos);
                    rowGroup.add(mesh);
                    planes.push(mesh);

                    // Label
                    const eqText = `${a}u ${b>=0?'+':''}${b}v ${c>=0?'+':''}${c}w = ${d}`;
                    const labelPos = centerPos.clone().add(new THREE.Vector3(2, 2, 2)); 
                    const lbl = createTextSprite(eqText, colors[i], labelPos, true);
                    labelsGroup.add(lbl);
                    sceneLabels.row.push(lbl);
                });
            } else {
                // 2D Lines
                matrix.forEach((row, i) => {
                    const [a, b, d] = row;
                    const pts = [];
                    const box = 15;
                    if (Math.abs(b) > 0.001) {
                        let y1 = (d - a * (-box)) / b; if (y1 >= -box && y1 <= box) pts.push(new THREE.Vector3(-box, y1, 0));
                        let y2 = (d - a * (box)) / b; if (y2 >= -box && y2 <= box) pts.push(new THREE.Vector3(box, y2, 0));
                    }
                    if (Math.abs(a) > 0.001) {
                        let x1 = (d - b * (-box)) / a; if (x1 >= -box && x1 <= box && pts.length < 2) pts.push(new THREE.Vector3(x1, -box, 0));
                        let x2 = (d - b * (box)) / a; if (x2 >= -box && x2 <= box && pts.length < 2) pts.push(new THREE.Vector3(x2, box, 0));
                    }

                    if (pts.length >= 2) {
                        const path = new THREE.Vector3().subVectors(pts[1], pts[0]);
                        const len = path.length();
                        const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, len, 8), i==0?materials.p1:materials.p2);
                        cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), path.normalize());
                        const mid = new THREE.Vector3().addVectors(pts[0], pts[1]).multiplyScalar(0.5);
                        cylinder.position.copy(mid);
                        cylinder.material = new THREE.MeshBasicMaterial({ color: i==0?0xff4444:0x44ff44 });
                        rowGroup.add(cylinder);
                        planes.push(cylinder);

                        // Label
                        const eqText = `${a}u ${b>=0?'+':''}${b}v = ${d}`;
                        const lbl = createTextSprite(eqText, colors[i], mid.clone().add(new THREE.Vector3(0, 1, 0)), true);
                        labelsGroup.add(lbl);
                        sceneLabels.row.push(lbl);
                    }
                });
            }
            
            // Intersection Point Label
            intersectPoint = new THREE.Mesh(new THREE.SphereGeometry(0.4), materials.pt);
            intersectPoint.position.set(solution.u, solution.v, solution.w);
            intersectPoint.visible = false;
            rowGroup.add(intersectPoint);
            
            const ptText = currentDim === 3 
                ? `(${solution.u.toFixed(1)}, ${solution.v.toFixed(1)}, ${solution.w.toFixed(1)})` 
                : `(${solution.u.toFixed(1)}, ${solution.v.toFixed(1)})`;
            const ptLbl = createTextSprite(ptText, '#ffff00', intersectPoint.position.clone().add(new THREE.Vector3(0, -1.5, 0)), true);
            ptLbl.visible = false;
            labelsGroup.add(ptLbl);
            sceneLabels.point = ptLbl;

            // --- COLUMN PICTURE ---
            const cols = [];
            for(let j=0; j<currentDim; j++) {
                if (currentDim === 3) cols.push(new THREE.Vector3(matrix[0][j], matrix[1][j], matrix[2][j]));
                else cols.push(new THREE.Vector3(matrix[0][j], matrix[1][j], 0));
            }
            
            // Ghost vectors
            cols.forEach((v, i) => {
                if (v.lengthSq() < 0.001) return;
                const arr = new THREE.ArrowHelper(v.clone().normalize(), new THREE.Vector3(), v.length(), colors[i], 0.4, 0.2);
                arr.line.material.opacity = 0.2; arr.line.material.transparent = true;
                arr.cone.material.opacity = 0.2; arr.cone.material.transparent = true;
                colGroup.add(arr);
            });

            // Active Vectors
            let currentStart = new THREE.Vector3();
            const scalars = [solution.u, solution.v, solution.w];
            
            cols.forEach((v, i) => {
                const full = v.clone().multiplyScalar(scalars[i]);
                let dir = v.clone().normalize();
                if (scalars[i] < 0) dir.negate();
                if (full.lengthSq() < 0.0001) dir = new THREE.Vector3(1,0,0);

                const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(), 0.001, colors[i], 0.4, 0.2);
                colGroup.add(arrow);
                vectors.push({ arrow, full, start: currentStart.clone() });
                
                // Detailed Label: (x,y,z) * scalar
                // We'll update pos in animate, but create here
                let coordStr = "";
                if(currentDim === 3) coordStr = `[${v.x},${v.y},${v.z}]`;
                else coordStr = `[${v.x},${v.y}]`;
                
                const lblText = `${coordStr} · ${scalars[i].toFixed(2)}`;
                const lbl = createTextSprite(lblText, colors[i], new THREE.Vector3(), true);
                lbl.visible = false;
                labelsGroup.add(lbl);
                sceneLabels.col.push(lbl);

                currentStart.add(full);
            });

            let target;
            if (currentDim === 3) target = new THREE.Vector3(matrix[0][3], matrix[1][3], matrix[2][3]);
            else target = new THREE.Vector3(matrix[0][2], matrix[1][2], 0);

            finalVector = new THREE.ArrowHelper(target.clone().normalize(), new THREE.Vector3(), target.length(), 0xffff00, 0.6, 0.3);
            finalVector.visible = false;
            colGroup.add(finalVector);
            
            // Result Label
            let bStr = currentDim === 3 ? `b=[${target.x},${target.y},${target.z}]` : `b=[${target.x},${target.y}]`;
            const resLbl = createTextSprite(bStr, "#ffff00", target.clone(), true);
            resLbl.visible = false;
            labelsGroup.add(resLbl);
            sceneLabels.result = resLbl;

            // Volume
            if (vectors.length >= 2) {
                const s1 = vectors[0].full;
                const s2 = vectors[1].full;
                const positions = []; const colorAttr = [];
                const c1 = new THREE.Color(0xff4444), c2 = new THREE.Color(0x44ff44), c3 = new THREE.Color(0x4444ff), c0 = new THREE.Color(0x000000);
                const pushTri = (va, ca, vb, cb, vc, cc) => {
                    positions.push(va.x,va.y,va.z, vb.x,vb.y,vb.z, vc.x,vc.y,vc.z); colorAttr.push(ca.r,ca.g,ca.b, cb.r,cb.g,cb.b, cc.r,cc.g,cc.b);
                };
                const pushQuad = (va, ca, vb, cb, vc, cc, vd, cd) => { pushTri(va,ca, vb,cb, vc,cc); pushTri(va,ca, vc,cc, vd,cd); };

                if (currentDim === 3) {
                    const s3 = vectors[2].full;
                    const v0=new THREE.Vector3(), v1=s1, v2=s2, v3=s3;
                    const v4=s1.clone().add(s2), v5=s1.clone().add(s3), v6=s2.clone().add(s3), v7=s1.clone().add(s2).add(s3);
                    const c4=c1.clone().add(c2), c5=c1.clone().add(c3), c6=c2.clone().add(c3), c7=c4.clone().add(c3);
                    pushQuad(v0,c0, v1,c1, v4,c4, v2,c2); pushQuad(v3,c3, v5,c5, v7,c7, v6,c6);
                    pushQuad(v0,c0, v2,c2, v6,c6, v3,c3); pushQuad(v1,c1, v5,c5, v7,c7, v4,c4);
                    pushQuad(v0,c0, v1,c1, v5,c5, v3,c3); pushQuad(v2,c2, v4,c4, v7,c7, v6,c6);
                } else {
                    const v0=new THREE.Vector3(), v1=s1, v2=s1.clone().add(s2), v3=s2;
                    const c4=c1.clone().add(c2);
                    pushQuad(v0,c0, v1,c1, v2,c4, v3,c2);
                }
                const volGeom = new THREE.BufferGeometry();
                volGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                volGeom.setAttribute('color', new THREE.Float32BufferAttribute(colorAttr, 3));
                volGeom.computeVertexNormals();
                parallelepipedMesh = new THREE.Mesh(volGeom, materials.vol);
                parallelepipedMesh.visible = false;
                colGroup.add(parallelepipedMesh);
            }

            setMode(mode);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (isPlaying && solution.valid) {
                animationTime = Math.min(animationTime + animationSpeed, 1.1);
                updateScene(animationTime);
            }
            renderer.render(scene, camera);
        }

        function updateScene(t) {
            const numSteps = currentDim;
            const stepSize = 1.0/numSteps;

            if (mode === 'col') {
                vectors.forEach(v => v.arrow.setLength(0.001));
                finalVector.visible = false;
                
                // Hide all row labels
                sceneLabels.row.forEach(l => l.visible = false);
                if (sceneLabels.point) sceneLabels.point.visible = false;

                for(let i=0; i<numSteps; i++) {
                     const tStart = i*stepSize;
                     const localT = Math.min(Math.max((t - tStart)/stepSize, 0), 1);
                     
                     if (localT > 0 && visibilityState.col[i]) {
                         vectors[i].arrow.setLength(Math.max(0.001, vectors[i].full.length()*localT));
                         vectors[i].arrow.position.copy(vectors[i].start);
                         vectors[i].arrow.visible = true;
                         
                         // Update label pos to MIDPOINT
                         if(sceneLabels.col[i]) {
                             // Visibility Logic: Must be active, specific toggle on, AND global labels on
                             sceneLabels.col[i].visible = visibilityState.col[i] && visibilityState.labels;
                             // Calculate midpoint of CURRENT arrow length
                             const currentTip = vectors[i].full.clone().multiplyScalar(localT);
                             const midpoint = vectors[i].start.clone().add(currentTip.multiplyScalar(0.5));
                             sceneLabels.col[i].position.copy(midpoint);
                         }
                     } else {
                         vectors[i].arrow.visible = false;
                         if(sceneLabels.col[i]) sceneLabels.col[i].visible = false;
                     }
                }

                if (t >= 1 && visibilityState.col[numSteps]) {
                    finalVector.visible = true;
                    if(sceneLabels.result) sceneLabels.result.visible = visibilityState.labels;
                } else {
                    finalVector.visible = false;
                    if(sceneLabels.result) sceneLabels.result.visible = false;
                }

                if (parallelepipedMesh) {
                    parallelepipedMesh.visible = visibilityState.col[numSteps+1] && t >= 0.1;
                    parallelepipedMesh.material.opacity = Math.min(t * 0.3, 0.3);
                }
                
                const step = Math.min(Math.floor(t * numSteps) + 1, numSteps);
                document.getElementById('explanation-box').innerHTML = t>=1 ? "Result: Target vector <b class='text-yellow-400'>b</b> reached!" : `Step ${step}: Adding Column ${step}...`;
                
            } else {
                // Hide all col labels
                sceneLabels.col.forEach(l => l.visible = false);
                if (sceneLabels.result) sceneLabels.result.visible = false;

                for(let i=0; i<numSteps; i++) {
                    const tStart = i*stepSize;
                    const localT = Math.min(Math.max((t - tStart)/stepSize, 0), 1);
                    if (visibilityState.row[i]) {
                        planes[i].visible = localT > 0;
                        if (currentDim === 3) planes[i].material.opacity = 0.3 * localT;
                        if(sceneLabels.row[i]) sceneLabels.row[i].visible = (localT > 0) && visibilityState.labels;
                    } else {
                        planes[i].visible = false;
                        if(sceneLabels.row[i]) sceneLabels.row[i].visible = false;
                    }
                }
                
                let allRowVis = true;
                for(let i=0; i<numSteps; i++) if(!visibilityState.row[i]) allRowVis=false;
                const showPt = (t > 0.9 && allRowVis);
                intersectPoint.visible = showPt;
                if(sceneLabels.point) sceneLabels.point.visible = showPt && visibilityState.labels;
                
                const step = Math.min(Math.floor(t * numSteps) + 1, numSteps);
                document.getElementById('explanation-box').innerHTML = t>=1 ? `Intersection at <b class='text-yellow-400'>(${solution.u.toFixed(1)}, ${solution.v.toFixed(1)}${currentDim===3?', '+solution.w.toFixed(1):''})</b>` : `Step ${step}: Showing Equation ${step}...`;
            }
        }

        function setMode(m) {
            mode = m;
            document.getElementById('btn-row').className = `toggle-btn py-2 rounded-md text-xs font-bold uppercase tracking-wide ${m==='row'?'active':'text-slate-400'}`;
            document.getElementById('btn-col').className = `toggle-btn py-2 rounded-md text-xs font-bold uppercase tracking-wide ${m==='col'?'active':'text-slate-400'}`;
            rowGroup.visible = (m === 'row');
            colGroup.visible = (m === 'col');
            document.getElementById('mode-title-overlay').innerText = m === 'row' ? "Row Picture" : "Column Picture";
            renderVisibilityControls();
            resetAnimation();
        }

        function resetAnimation() { animationTime = 0; isPlaying = false; document.getElementById('play-btn').innerHTML = '<i class="fas fa-play"></i> Play'; updateScene(0); }
        function togglePlay() { isPlaying = !isPlaying; document.getElementById('play-btn').innerHTML = isPlaying ? '<i class="fas fa-pause"></i> Pause' : '<i class="fas fa-play"></i> Play'; if(animationTime>=1.1) animationTime=0; }
        
        function downloadSnapshot() {
            renderer.render(scene, camera);
            const w = renderer.domElement.width;
            const h = renderer.domElement.height;
            const footerH = 120;
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h + footerH;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(renderer.domElement, 0, 0);
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, h, w, footerH);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText("Linear System Visualization", 20, h + 30);
            ctx.font = '14px monospace';
            ctx.fillStyle = '#94a3b8';
            let startY = h + 55;
            matrix.forEach((row, i) => {
                let txt = "";
                if(currentDim === 3) txt = `${row[0]}u + ${row[1]}v + ${row[2]}w = ${row[3]}`;
                else txt = `${row[0]}u + ${row[1]}v = ${row[2]}`;
                ctx.fillText(txt, 20, startY + (i*18));
            });
            if (w > 400) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText("Solution:", w/2, h + 30);
                ctx.font = 'bold 18px monospace';
                ctx.fillStyle = solution.valid ? '#34d399' : '#ef4444';
                let solTxt = "No Unique Solution";
                if (solution.valid) {
                    solTxt = currentDim === 3 
                        ? `(${solution.u.toFixed(2)}, ${solution.v.toFixed(2)}, ${solution.w.toFixed(2)})` 
                        : `(${solution.u.toFixed(2)}, ${solution.v.toFixed(2)})`;
                }
                ctx.fillText(solTxt, w/2, h + 55);
            }
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
            link.download = `linear_system_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function generateInputs() {
            const container = document.getElementById('matrix-inputs');
            container.innerHTML = '';
            const vars = ['u','v','w'];
            const n = currentDim;
            matrix.forEach((row, i) => {
                const div = document.createElement('div');
                div.className = "flex items-center gap-1";
                for(let j=0; j<n; j++) {
                    div.innerHTML += `<input type="number" value="${row[j]}" onchange="updateM(${i},${j},this.value)" class="bg-slate-700 rounded px-1 w-10 text-center"><span class="text-slate-500 w-3">${vars[j]}</span>${j<n-1?'+':''}`;
                }
                div.innerHTML += `= <input type="number" value="${row[n]}" onchange="updateM(${i},${n},this.value)" class="bg-slate-700 rounded px-1 w-10 text-center">`;
                container.appendChild(div);
            });
        }
        window.updateM = (r, c, v) => { matrix[r][c] = parseFloat(v); solveSystem(); initVisuals(); resetAnimation(); };
        window.resetToDefault = () => { if(currentDim===3) matrix = JSON.parse(JSON.stringify(defaultMatrix3D)); else matrix = JSON.parse(JSON.stringify(defaultMatrix2D)); generateInputs(); solveSystem(); initVisuals(); resetAnimation(); };
        function updateSolutionUI() {
            const el = document.getElementById('solution-display');
            if(solution.valid) { 
                const txt = currentDim===3 ? `(${solution.u.toFixed(2)}, ${solution.v.toFixed(2)}, ${solution.w.toFixed(2)})` : `(${solution.u.toFixed(2)}, ${solution.v.toFixed(2)})`;
                el.innerText = txt; el.className="font-mono text-emerald-400 text-base font-bold"; 
            }
            else { el.innerText = "No Unique Solution"; el.className="font-mono text-red-500 text-sm font-bold"; }
        }

        generateInputs(); solveSystem(); initVisuals(); animate();
        
        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        });

    </script>
</body>
</html>
